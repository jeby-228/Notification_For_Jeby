package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"member_API/graphql/model"
	"member_API/models"
	"strconv"
	"time"
)

// Member is the resolver for the member field.
func (r *queryResolver) Member(ctx context.Context, id string) (*model.Member, error) {
	if r.DB == nil {
		return nil, nil
	}
	var m models.Member
	if err := r.DB.First(&m, id).Error; err != nil {
		return nil, nil
	}
	return dbToModel(m), nil
}

// Members is the resolver for the members field.
func (r *queryResolver) Members(ctx context.Context, limit *int) ([]*model.Member, error) {
	if r.DB == nil {
		return []*model.Member{}, nil
	}
	lim := 50
	if limit != nil && *limit > 0 {
		lim = *limit
	}
	var rows []models.Member
	if err := r.DB.Select("id", "name", "email", "created_at", "updated_at").Limit(lim).Find(&rows).Error; err != nil {
		return nil, err
	}
	out := make([]*model.Member, len(rows))
	for i, m := range rows {
		out[i] = dbToModel(m)
	}
	return out, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

func dbToModel(m models.Member) *model.Member {
	var created, updated *string
	if !m.CreatedAt.IsZero() {
		s := formatTime(m.CreatedAt)
		created = &s
	}
	if !m.UpdatedAt.IsZero() {
		s := formatTime(m.UpdatedAt)
		updated = &s
	}
	return &model.Member{
		ID:        formatID(m.ID),
		Name:      m.Name,
		Email:     m.Email,
		CreatedAt: created,
		UpdatedAt: updated,
	}
}

func formatTime(t time.Time) string {
	return t.UTC().Format(time.RFC3339)
}

func formatID(id uint) string {
	return fmtUint(id)
}

func fmtUint(u uint) string { return strconv.FormatUint(uint64(u), 10) }
